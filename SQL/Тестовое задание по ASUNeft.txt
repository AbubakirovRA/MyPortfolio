Задание №1

Сколько записей в данном фрагменте удовлетворяют условию:
1. (Категория поезда = «скорый») ИЛИ (Вокзал = «Павелецкий») - 9;
2. (Категория поезда = «скорый») И (Время в пути 40:00) - 0;
3. (Вокзал = «Павелецкий») ИЛИ (Время в пути 35:00) - 0;


Задание №2.

Создаем таблицы:

mysql> INSERT INTO Таблица_1(ID, `Фамилия_И._О.`, `Пол`)
    -> VALUES
    -> (1588, 'Саенко М.А.', 'Ж');
Query OK, 1 row affected (0.13 sec)

mysql> select * from Таблица_1
    -> ;
+------+---------------+-----+
| ID   | ФАМИЛИЯ_И._О. | Пол |
+------+---------------+-----+
| 1588 | Саенко М.А.   | Ж   |
+------+---------------+-----+
1 row in set (0.00 sec)

mysql> INSERT INTO Таблица_1(ID, `Фамилия_И._О.`, `Пол`)
    -> VALUES
    -> (1616, 'Билич А.П.', 'М'),
    -> (1683, 'Виктюк И.Б.', 'М'),
    -> (1748, 'Кеосаян А.И.', 'Ж'),
    -> (1960, 'Виктюк П.И.', 'М'),
    -> (1974, 'Тузенбах П.А.', 'Ж'),
    -> (2008, 'Виктюк Б.Ф.', 'М'),
    -> (2106, 'Чижик Д.К.', 'Ж'),
    -> (2339, 'Седых Л.А.', 'М'),
    -> (2349, 'Виктюк А.Б.', 'Ж'),
    -> (2521, 'Меладзе К.Г.', 'М'),
    -> (2593, 'Билич П.А.', 'М'),
    -> (2730, 'Виктюк Т.И.', 'Ж'),
    -> (2860, 'Панина Р.Г.', 'Ж'),
    -> (2882, 'Шевченко Р.Г.', 'Ж'),
    -> (2911, 'Седых В.А.', 'Ж');
Query OK, 15 rows affected (0.09 sec)
Records: 15  Duplicates: 0  Warnings: 0

mysql> create table test.Таблица_2
    -> (
    -> `ID_Родителя` NOT NULL,
    -> `ID_Ребенка` INT NOT NULL);
Query OK, 0 rows affected (0.14 sec)

mysql> INSERT INTO Таблица_2(`ID_Родителя`, `ID_Ребенка`)
    -> VALUES
    -> (1616, 1588),
    -> (2349, 1588),
    -> (2008, 1683),
    -> (2106, 1683),
    -> (1683, 1960),
    -> (2882, 1960),
    -> (2860, 1974),
    -> (2860, 2339),
    -> (2008, 2349),
    -> (2106, 2349),
    -> (1616, 2593),
    -> (2349, 2593),
    -> (1683, 2730),
    -> (2882, 2730),
    -> (1616, 2911),
    -> (2349, 2911);
Query OK, 16 rows affected (0.14 sec)
Records: 16  Duplicates: 0  Warnings: 0

mysql> select * FROM Таблица_2
    -> ;
+-------------+------------+
| ID_Родителя | ID_Ребенка |
+-------------+------------+
|        1616 |       1588 |
|        1683 |       1960 |
|        2008 |       1683 |
|        2106 |       1683 |
|        2349 |       1588 |
|        2860 |       1974 |
|        2882 |       1960 |
|        2860 |       2339 |
|        2008 |       2349 |
|        2106 |       2349 |
|        1616 |       2593 |
|        2349 |       2593 |
|        1683 |       2730 |
|        2882 |       2730 |
|        1616 |       2911 |
|        2349 |       2911 |
+-------------+------------+
16 rows in set (0.00 sec)

1. На основании приведённых данных определите ID родного брата Седых В.А.
Решение:
1.1 Для нахождения родного брата, нужно найти родителей Седых В.А., для этого определяем
уникальный ID Седых В.А. - 2911.
1.2 Далее, в Таблице_2 по этому ID, находим ID родителей Седых В.А., это люди с ID_Родителя
1616 и 2349.
1.3 Далее нужно найти все ID_Ребенка у которых хотя бы одним родителем являются 
выше найденные ID_Родителя 1616 и 2349. Это 1588 и 2593.
1.4 Определяем по таблице_1 являются ли данные люди мужчинами, мужчиной является
ID 2593 - Билич П.А.

Для создания запроса нам по сути нужна информация из трех столбцов: столбец ID Таблицы_1,
и оба столбца таблицы_2.

Начнем конструировать запрос с конца.

Запрос по п.п.1.4-1.3

mysql> select `Таблица_1`.`ФАМИЛИЯ_И._О.`
    -> from `Таблица_1`
    -> where
    -> `Пол`='М' and `ID` in (1588, 2593);
+---------------+
| ФАМИЛИЯ_И._О. |
+---------------+
| Билич П.А.    |
+---------------+
1 row in set (0.00 sec)

Запрос по п.1.2.
mysql> select `Таблица_2`.`ID_Родителя`
    -> from `Таблица_2`
    -> where
    -> `ID_Ребенка`=2911;
+-------------+
| ID_Родителя |
+-------------+
|        1616 |
|        2349 |
+-------------+
2 rows in set (0.00 sec)

Запрос по п.п.1.2-1.3
mysql> select distinct `Таблица_2`.`ID_Ребенка`
    -> from `Таблица_2`
    -> where `ID_Родителя` in
    -> (select `Таблица_2`.`ID_Родителя` from `Таблица_2` where `ID_Ребенка`=2911);
+------------+
| ID_Ребенка |
+------------+
|       1588 |
|       2593 |
|       2911 |
+------------+
3 rows in set (0.00 sec)

определяем ID Седых В.А.
mysql> select `Таблица_1`.`ID`
    -> from `Таблица_1`
    -> where `ФАМИЛИЯ_И._О.`= 'Седых В.А.';
+------+
| ID   |
+------+
| 2911 |
+------+
1 row in set (0.00 sec)

Теперь упаковываем все запросы в один сложный запрос:

mysql> select `Таблица_1`.`ID`
    -> from `Таблица_1`
    -> where
    -> `Пол`='М' and `ID` in (select distinct `Таблица_2`.`ID_Ребенка` from `Таблица_2` where `ID_Родителя` in
    -> (select `Таблица_2`.`ID_Родителя` from `Таблица_2` where `ID_Ребенка`=
    -> (select `Таблица_1`.`ID` from `Таблица_1` where `ФАМИЛИЯ_И._О.`= 'Седых В.А.')));
+------+
| ID   |
+------+
| 2593 |
+------+
1 row in set (0.00 sec)

Ответ: ID родного брата Саенко В.А. - 2593 (Билич П.А.)

Оптимизируем наш код, с помощью опреаторов COUNT и JOIN:

SELECT t1.`ФАМИЛИЯ_И._О.`, COUNT(t2.`ID_Ребенка`) as `Количество детей`
FROM Таблица_1 t1
JOIN Таблица_2 t2 ON t1.ID = t2.`ID_Родителя`
GROUP BY t1.`ФАМИЛИЯ_И._О.`

Рассмотрим работу кода подробнее:

Код выполняет следующую задачу: для каждой пары "родитель-ребенок" находит все "дедушек" и "бабушек" (т.е. родителей родителей) этой пары. 
Кроме того, запрос выводит количество найденных "дедушек" и "бабушек" для каждой пары.

Давайте посмотрим на код подробнее:

SELECT t1.ID_Родителя, t1.ID_Ребенка, COUNT(t2.ID_Родителя) as 'Кол-во дедушек', COUNT(t3.ID_Родителя) as 'Кол-во бабушек'
FROM Таблица_2 t1
LEFT JOIN Таблица_2 t2 ON t1.ID_Родителя = t2.ID_Ребенка
LEFT JOIN Таблица_2 t3 ON t1.ID_Родителя = t3.ID_Ребенка
WHERE t2.ID_Родителя IS NOT NULL AND t3.ID_Родителя IS NOT NULL
GROUP BY t1.ID_Родителя, t1.ID_Ребенка;

Первая строка определяет, какие столбцы должны быть выбраны. В данном случае мы выбираем столбцы ID_Родителя и ID_Ребенка из таблицы Таблица_2. 
Кроме того, мы используем функцию COUNT для подсчета количества найденных "дедушек" и "бабушек".

Вторая строка задает три таблицы с помощью алиасов t1, t2 и t3. 
Первая таблица (с алиасом t1) - это таблица Таблица_2, которая содержит информацию о "родителе-ребенке". 
Вторая таблица (с алиасом t2) - это копия таблицы Таблица_2, которая связывается с первой таблицей по столбцу ID_Родителя из первой таблицы 
и столбцу ID_Ребенка из второй таблицы. Это позволяет нам получить информацию о "дедушках" (т.е. родителях родителей) для каждой пары "родитель-ребенок". 
Третья таблица (с алиасом t3) - это еще одна копия таблицы Таблица_2, которая связывается с первой таблицей по столбцу ID_Родителя из первой таблицы 
и столбцу ID_Ребенка из третьей таблицы. 
Это позволяет нам получить информацию о "бабушках" (т.е. родителях матери и отца) для каждой пары "родитель-ребенок".

Третья строка:

FROM Таблица_2 AS t1

Эта строка создает алиас t1 для таблицы Таблица_2. 
Алиас позволяет ссылаться на таблицу по короткому имени в запросе. 
Здесь AS - необязательное ключевое слово, которое используется для ясности.

Четвертая строка:
JOIN Таблица_2 AS t2 ON t2.ID_Ребенка = t1.ID_Родителя

Эта строка соединяет таблицу Таблица_2 с самой собой по полю ID_Ребенка, равному полю ID_Родителя. 
Она создает алиас t2 для таблицы Таблица_2. 
По сути, это соединение используется для получения всех пар родитель-ребенок, где ребенок также является родителем для другого ребенка.

Пятая строка:
WHERE t1.ID_Родителя NOT IN (SELECT DISTINCT ID_Ребенка FROM Таблица_2)

Эта строка фильтрует результаты, оставляя только те строки, где ID_Родителя не является ID_Ребенка в других строках таблицы. 
Иными словами, мы получаем только корневые элементы дерева, у которых нет родителей.

Шестая и последняя строка:
ORDER BY t1.ID_Родителя ASC, t1.ID_Ребенка ASC

Эта строка сортирует результаты по ID_Родителя по возрастанию, а затем по ID_Ребенка по возрастанию. 
Таким образом, полученный список является отсортированным по иерархии элементов дерева, начиная с корневых элементов.

Короткий код, который я написал, основан на использовании функции GROUP_CONCAT в MySQL. 
Функция GROUP_CONCAT позволяет объединить строки в одну, используя определенный разделитель.

В моем коротком коде я использую подзапрос, который выбирает всех детей для каждого родителя из таблицы Таблица_2 и объединяет их ID в одну строку, 
разделенную запятой. 
Затем я присоединяю этот подзапрос к таблице Таблица_1 по ID и получаю таблицу, содержащую имена родителей и ID имен их детей, разделенные запятыми.

Кроме того, я использовал алиасы t1 и t2, чтобы сделать код более читабельным. 
Алиас t1 относится к таблице Таблица_1, а алиас t2 относится к таблице Таблица_2. 
Это позволяет мне ссылаться на столбцы таблиц, используя более короткие и понятные имена.


2. Сколько братьев у Саенко М.А.

Повторим тот же запрос, но с параметром Саенко М.А. и оператором COUNT
mysql> select count(`Таблица_1`.`ID`) as `Количество`
    -> from `Таблица_1`
    -> where
    -> `Пол`='М' and `ID` in (select distinct `Таблица_2`.`ID_Ребенка` from `Таблица_2` where `ID_Родителя` in
    -> (select `Таблица_2`.`ID_Родителя` from `Таблица_2` where `ID_Ребенка`=
    -> (select `Таблица_1`.`ID` from `Таблица_1` where `ФАМИЛИЯ_И._О.`= 'Саенко М.А.')));
+------------+
| Количество |
+------------+
|          1 |
+------------+
1 row in set (0.06 sec)

Можно оптимизировать этот запрос, заменив подзапросы на соединения таблиц. Вот как будет выглядеть оптимизированный запрос:

SELECT COUNT(`t1`.`ID`) as `Количество`
FROM `Таблица_1` AS `t1`
JOIN `Таблица_2` AS `t2` ON `t1`.`ID` = `t2`.`ID_Ребенка`
JOIN `Таблица_2` AS `t3` ON `t2`.`ID_Родителя` = `t3`.`ID_Родителя`
WHERE `t1`.`Пол` = 'М'
AND `t1`.`ФАМИЛИЯ_И._О.` = 'Саенко М.А.';

В этом запросе мы сначала объединяем таблицы Таблица_1 и Таблица_2 с помощью операторов JOIN, 
а затем фильтруем результаты с помощью условий Пол='М' и ФАМИЛИЯ_И._О.='Саенко М.А.'. 
Результатом будет количество записей, удовлетворяющих этим условиям.


3. Вывести список детей из неполных семей.
Для решения этой задачи нужно выбрать те ID детей из Таблица_2.ID_Ребенка, которые 
содержатся в таблице только один раз, так как им сопоставлен только один родитель. 
После чего найти по этим ID значения в столбцах Фамилия_И._О. и Пол Таблица_1.

mysql> select `Таблица_1`.`ФАМИЛИЯ_И._О.`,  `Таблица_1`.`Пол`
    -> from `Таблица_1` inner join `Таблица_2` on `Таблица_1`.`ID` = `Таблица_2`.`ID_Ребенка`
    -> group by `Таблица_2`.`ID_Ребенка`, `Таблица_1`.`ФАМИЛИЯ_И._О.`,  `Таблица_1`.`Пол`
    -> having (((count(`Таблица_2`.`ID_Ребенка`))=1))
    -> order by  `Таблица_1`.`ФАМИЛИЯ_И._О.`;

Конечный результат запроса будет содержать только уникальные имена и пол детей из Таблица_1, у которых есть только один родитель в Таблица_2.

Первый шаг запроса - соединение двух таблиц (Таблица_1 и Таблица_2) с помощью внутреннего соединения (INNER JOIN). 
В этом соединении используются два условия:

- `Таблица_1`.`ID` = `Таблица_2`.`ID_Ребенка` - для соединения записей, где ID из Таблица_1 соответствует ID_Ребенка из Таблица_2;

- `count(distinct `Таблица_2`.`ID_Родителя`) = 1` - для нахождения записей, у которых только один родитель в Таблица_2. 
Здесь функция COUNT используется для подсчета уникальных значений ID_Родителя для каждого ребенка из Таблица_2. 
Если количество уникальных значений равно 1, то это означает, что у данного ребенка только один родитель.

Далее происходит группировка записей по `Таблица_2`.`ID_Ребенка`, `Таблица_1`.`ФАМИЛИЯ_И._О.` и `Таблица_1`.`Пол`, 
что означает, что записи будут сгруппированы по имени, полу и ID ребенка, чтобы можно было выполнить условие having.

После этого используется условие `having (((count(`Таблица_2`.`ID_Ребенка`))=1))`, которое фильтрует только те записи, у которых только один родитель в Таблица_2. 
Это достигается с помощью функции COUNT, которая подсчитывает количество записей для каждого ребенка из Таблица_2, у которых есть связь с родителем в этой таблице. Если это количество равно 1, то это означает, что у данного ребенка только один родитель.

Наконец, результат сортируется по `Таблица_1`.`ФАМИЛИЯ_И._О`. в алфавитном порядке:

+---------------+-----+
| ФАМИЛИЯ_И._О. | Пол |
+---------------+-----+
| Седых Л.А.    | М   |
| Тузенбах П.А. | Ж   |
+---------------+-----+
2 rows in set (0.00 sec)

Можно оптимизировать этот запрос, используя сокращения таблицы и уменьшив количество полей в выборке:

SELECT t1.`ФАМИЛИЯ_И._О.`, t1.`Пол`
FROM `Таблица_1` t1
INNER JOIN (
    SELECT `ID_Ребенка`
    FROM `Таблица_2`
    GROUP BY `ID_Ребенка`
    HAVING COUNT(*) = 1
) t2 ON t1.`ID` = t2.`ID_Ребенка`
ORDER BY t1.`ФАМИЛИЯ_И._О.`;

Этот запрос делает следующее:

В подзапросе выбираются все ID_Ребенка, которые встречаются только один раз в таблице Таблица_2.
Затем таблицы Таблица_1 и Таблица_2 объединяются с использованием оператора INNER JOIN по полю ID.
В результате выбираются только поля ФАМИЛИЯ_И._О. и Пол из таблицы Таблица_1.
Результат группируется по полю ID_Ребенка, ФАМИЛИЯ_И._О. и Пол.
Группы, в которых количество записей больше одной, отфильтровываются с помощью оператора HAVING.
Результат сортируется по полю ФАМИЛИЯ_И._О. в алфавитном порядке.
Таким образом, этот запрос оптимизирован и даёт тот же результат, что и исходный, но выполняется более эффективно.